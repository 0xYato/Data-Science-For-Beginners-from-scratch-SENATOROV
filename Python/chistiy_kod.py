"""Чистый код."""

# # Глава 1. Трассировка ошибок
#
# Traceback (most recent call last):
#
#   File "main.py", line 10, in <module>
#
#     result = divide(10, 0)
#
#   File "main.py", line 5, in divide
#
#     return a / b
#
# ZeroDivisionError: division by zero
#
# Читать нужно снизу вверх
#
# Последняя строка содержит тип ошибки и её описание
#
# Выше показан путь к месту ошибки

# # Глава 2 Подготовка среды и командная строка
#
# Подготовкой среды называется процесс настройки вашего
# компьютера для программирования.
#
# В Windows для разделения имен папок и файлов используется символ \ (обратная
# косая черта), а в macOS и Linux разделителем является символ / (косая черта).
#
# Программы командной оболочки:
#
#  Bourne Shell (sh) - Linux
#
#  Bourne-Again Shell (bash) - Linux
#
#  Z shell (zsh) - MacOS
#
#  Командная строка - Windows
#
#  **Аргументы командной строки** - текстовые фрагменты, которые
# вводятся после имени команды. Как и аргументы, передаваемые при вызове функций
# Python, они предоставляют команде дополнительную информацию или указания.
# Например, при выполнении команды cd C:\Users часть C:\Users является аргументом
# команды cd, которая сообщает команде, какая папка должна стать текущим рабочим
# каталогом. Или при запуске сценария Python из окна терминала командой python
# yourScript.py часть yourScript.py является аргументом, который сообщает программе python, в каком файле следует искать выполняемую последовательность команд.
#
# **Ключи командной строки** - краткие аргументы, часто начинаются с - или --
#
# **Поиск файлов начинающихся с определенного символа:**
#
# al@al-VirtualBox:~$ cd D
#
# Desktop/ Documents/ Downloads/
#
# al@al-VirtualBox:~$ cd D
#
# При нажатии клавиши ↑ в терминале командная строка заполняется
# последней введенной вами командой. Дальнейшие нажатия клавиши ↑ продолжают
# перебирать более ранние команды, а нажатия клавиши ↓ возвращают к более поздним командам. Если вы хотите отменить команду в приглашении и начать с нового
# приглашения, нажмите Ctrl-C.
#
# **Изменение текущего рабочего каталога. Работа с ним.**
#
# # cd [папка]
#
# Команда ls выводит список всех папок и файлов находящихся в рабочем каталоге
#
# Чтобы вывести подробную информацию
# с размером файла, разрешениями, временными метками последнего изменения
# и другой информацией, используйте ключ -l.
#
# Чтобы команда ls выводила все файлы, включая скрытые,
# используйте ключ -a.
#
# find выводит содержимое текущего рабочего каталога
# и его подкаталогов.
#
# find . -name "*.py"
#
# Символ . приказывает find начать поиск в текущем рабочем каталоге. С ключом
# -name команда find ищет папки и файлы по имени. Фрагмент "*.py" приказывает
# find искать папки и файлы с именами, соответствующими шаблону *.py. Следует
# заметить, что команда find требует, чтобы аргумент после -name был заключен
# в двойные кавычки.
#
# # cp hello.py someSubFolder - скопировать нужный файл в нужное место: cd [нужный файл][нужное место]
#
# команда mv [файл или папка] [новое имя] переименовывает файл
#
# # mv hello.py goodbye.py
#
# # rm [файл] - удалить файл
#
# # rm -r [папка] - удалить папку
#
# mkdir[новая папка] - создать новую папку
#
# which [программа] - сообщает точное местонахождение программы
#
# clear - стирает весь текст в окне терминала
#
# ## Переменная среда PATH
#
# Переменная PATH — это системная переменная, которую операционная система использует для того, чтобы найти нужные исполняемые объекты в командной строке или окне терминала.
#
# env - просмотр списка переменных среды
#
# Слева от знака равенства (=) указывается имя переменной среды, а справа — строковое значение.
#
# export PATH=/newFolder:$PATH - чтобы добавить новые папки в переменную path нужно изменить текстовый файл  .zshrc в домашней папке, добавив в него данную строку
#
# # 3 Глава. Форматирование кода при помощи black.
#
# PEP8 - сводка правил написания кода python, по нему и работает black
#
# ### Использование пробелов для создания отступов
#
# Что лучше - табуляция или пробел?
#
# >>> print('Hello there, friend!\nHow are you?')
# Hello there, friend!
# How are you?
# >>> print('Hello\tthere,\tfriend!\nHow\tare\tyou?')
# Hello   there,  friend!
# How     are     you?
#
# Пробел всегда выводится на
# экран как строковое значение, состоящее из одного пробела —
# ' '. А символ табуляции, который выводится как строковое значение, содержащее служебный символ
# '\t', не столь однозначен. Символы табуляции часто (хотя и не всегда) выводятся
# как переменное количество пробелов, чтобы текст начинался со следующей позиции
# табуляции. Лучше выбрать пробел.
#
# Также не следует смешивать пробелы и символы табуляции для создания отступов в одном блоке кода. Использование обоих символов настолько часто становилось причиной коварных ошибок в более ранних программах Python, что в Python 3 код с такими отступами даже не выполняется — выдается исключение TabError: inconsistent use of tabs and spaces in indentation
#
# Что касается длины каждого уровня отступов, в Python один уровень обычно обо-
# значен четырьмя пробелами.
#
# Также стоит отделять операторы от идентификаторов одним пробелом
#
# Ставьте два пробела перед комментариями в конце строки
#
# print('Hello, world!')  # Вывод приветствия.
#
# Пример правильного использования вертикальных отступов:
#
# class ExampleClass:
#
#     def exampleMethod1():
#         pass
#
#     def exampleMethod2():
#         pass
#
# def exampleFunction():
#         pass
#
# Python предоставляет одну возможность, о которой знают не все: точка с запятой
# (;) может использоваться для разделения нескольких команд в одной строке
#
# print('What is your name?'); name = input()
#
# if name == 'Alice': print('Hello, Alice!')
#
# Обычно такое написание затрудняет читаемость команд, так что  Black разбивает такие команды на отдельные строки.
#
# Аналогичным образом можно импортировать несколько модулей одной командой:
#
# import:
#
# import math, os, sys
#
# Тем не менее PEP 8 рекомендует разбить эту команду на несколько коротких команд, по одной для каждого модуля:
# import math
# import os
# import sys
#
# PEP8 также рекомендует объединять команды import в следующие три группы
# в указанном порядке.
# 1. Модули стандартной библиотеки Python: math, os, sys и т. д.
# 2. Сторонние модули: Selenium, Requests, Django и т. д.
# 3. Локальные модули, являющиеся частью программы.
#
# ## Black
#
# Black автоматически форматирует код в ваших файлах .py.
#
# Его название (Black — черный) происходит от знаменитого высказывания
# Генри Форда относительно цветов выпускаемых автомобилей: «Цвет автомобиля
# может быть любым, при условии что он черный».
#
# ### Предварительный просмотр изменений, вносимых Black
#
# C:\Users\Al>python -m black --diff yourScript.py
#
# Например, если yourScript.py
# содержит строку weights=[42.0,3.1415,2.718], при выполнении с ключом --diff
# будет выведен следующий результат:
# C:\Users\Al\>python -m black --diff yourScript.py
# --- yourScript.py 2020-12-07 02:04:23.141417 +0000
# +++ yourScript.py 2020-12-07 02:08:13.893578 +0000
# @@ -1 +1,2 @@
# -weights=[42.0,3.1415,2.718]
# +weights = [42.0, 3.1415, 2.718]
#
#
# Знак «минус» означает, что Black удалит строку weights=[42.0,3.1415,2.718] и заменит ее строкой, которая выводится с префиксом «плюс»: weights = [42.0, 3.1415, 2.718].
#
# ### Отключение Black для отдельных частей кода
#
# Добавив комментарии # fmt: off и # fmt: on, можно запретить Black форматирование
# строк в этом фрагменте, а затем продолжить его:
#
# ####### Константы для разных промежутков времени:
#
# ####### fmt: off
#
# SECONDS_PER_MINUTE = 60
#
# SECONDS_PER_HOUR = 60 * SECONDS_PER_MINUTE
#
# SECONDS_PER_DAY = 24 * SECONDS_PER_HOUR
#
# SECONDS_PER_WEEK = 7 * SECONDS_PER_DAY
#
# ####### fmt: on
#
# # Глава 4. Выбор понятных имён.
#
# Змеиный регистр (snake_case) разделяет слова символом подчеркивания,
# который напоминает ползущую между словами змею. В этом случае все
# буквы записываются в нижнем регистре, а константы часто записываются
#
# в верхнем змеином регистре (UPPER_SNAKE_CASE).
# Верблюжий регистр (camelCase) — слова записываются в нижнем регистре,
# но второе и следующие слова начинаются с заглавной. Эта схема в большинстве
# случаев подразумевает, что первое слово начинается с буквы нижнего
# регистра. Буквы верхнего регистра напоминают верблюжьи горбы.
#
# Схема Pascal (PascalCase) — названа так, потому что применяется в языке
# программирования Pascal; аналогична схеме верблюжьего регистра, но первое
# слово в ней тоже начинается с заглавной.
#
# **Сводка правил из PEP 8 по переменным:**
#
# - Все буквы должны быть буквами ASCII — то есть латинскими буквами
# верхнего и нижнего регистров без диакритических знаков.
#
# - Имена модулей должны быть короткими и состоять только из букв нижнего
# регистра.
#
# - Имена классов необходимо записывать в схеме Pascal.
#
# - Имена констант следует записывать в верхнем змеином регистре.
#
# - Имена функций, методов и переменных записывают в нижнем змеином
# регистре.
#
# - Первый аргумент методов всегда должен называться self в нижнем регистре.
#
# - Первый аргумент методов классов всегда должен называться cls в нижнем
# регистре.
#
# - Приватные атрибуты классов всегда начинают с символа подчеркивания ( _ ).
# - Публичные атрибуты классов никогда не начинают с символа подчеркивания ( _ ).
#
# Выбирайте имена, пригодные для поиска (закладывайте уникальность)
#
# Не заменяйте встроенные имена
#
# # Глава 5. Поиск запахов в коде.(Что может стать причиной ошибки?)
#
# Самый распространенный источник ошибок — ***дублирование кода.***
#
# Проблема решается функцией или циклом
#
# ***Закомментированный и мертвый код***
#
# Мертвым называется код, который недоступен или никогда не может быть выполнен на логическом уровне.
#
# ***Переменные с числовыми суффиксами***
#
# Пример - num1 num2 num 3 num4
#
# Если количество числовых суффиксов больше двух, стоит подумать об использовании структур: списка или множества для хранения данных в виде коллекции.
#
# ***Классы, которые должны быть функциями или модулями***
#
# Не стоит закладывать в класс функцию, которую можно заменить на простой вызов встроенной/пользовательской функции.
#
# ***Списковые включения внутри списковых включений***
#
# Вложенные списковые включения (или вложенные включения множеств/
# словарные включения) упаковывают значительную сложность в небольшой объем
# кода, что усложняет его чтение. Лучше развернуть списковое включение в один
# или несколько циклов for
#
# ***Пустые блоки except и плохие сообщения об ошибках***
#
#
# # Глава 6. Написание питонического кода.
#
# «Дзен Python» — набор из 20 руководящих принципов проектирования языка
# Python и программ Python, написанный Тимом Петерсом.
#
# The Zen of Python, by Tim Peters
#
# Beautiful is better than ugly.
#
# Explicit is better than implicit.
#
# Simple is better than complex.
#
# Complex is better than complicated.
#
# Flat is better than nested.
#
# Sparse is better than dense.
#
# Readability counts.
#
# Special cases aren't special enough to break the rules.
#
# Although practicality beats purity.
#
# Errors should never pass silently.
#
# Unless explicitly silenced.
#
# In the face of ambiguity, refuse the temptation to guess.
#
# There should be one-- and preferably only one --obvious way to do it.
#
# Although that way may not be obvious at first unless you're Dutch.
# Now is better than never.
#
# Although never is often better than *right* now.
#
# If the implementation is hard to explain, it's a bad idea.
#
# If the implementation is easy to explain, it may be a good idea.
#
# Namespaces are one honking great idea -- let's do more of those!
#
#
# Правило: сначала заставьте свой код работать, а потом
# переходите к оптимизации. Когда у вас уже имеется работоспособная программа,
# тогда и стоит браться за повышение ее эффективности.
#
# Стоит использовать:
#
#   - enumerate вместо range(len())
#
#   - with вместо open() и close()
#
#   - is для сравнения с None вместо ==
#
#   - необработанную строку (raw), если строка содержит много символов \
#
#   - Форматирование с использованием F-строк
#
#   - get() и setdefault() со словарями:
#
#         Вызов numberOfPets.get('cats', 0) проверяет, существует ли ключ 'cats' в словаре numberOfPets. Если он существует, то вызов метода возвращает значение для
#         ключа 'cats'. Если ключ не существует, вместо значения возвращается второй
#         аргумент 0. Использование метода get() с определением значения по умолчанию,
#         которое должно использоваться для несуществующих ключей, короче и лучше
#         читается, чем решение с командами if-else.
#
#
#         numberOfPets.setdefault('cats', 0) # Ничего не делать, если 'cats' существует.
#
#   - collections.defaultdict для значений по умолчанию:
#
#         >>> import collections
#         >>> scores = collections.defaultdict(int)
#         >>> scores
#         defaultdict(<class 'int'>, {})
#         >>> scores['Al'] += 1 # Не нужно сначала задавать значение для ключа 'Al'.
#         >>> scores
#         defaultdict(<class 'int'>, {'Al': 1})
#         >>> scores['Zophie'] # Не нужно сначала задавать значение для ключа 'Zophie'.
#         0
#         >>> scores['Zophie'] += 40
#         >>> scores
#         defaultdict(<class 'int'>, {'Al': 1, 'Zophie': 40})
#
#   - словари вместо многократных if-elif-else
#
#
# ### Проверка того, что переменная содержит одно из нескольких значений
#
#     >>> # Пример питонического кода.
#     >>> spam = 'cat'
#     >>> spam in ('cat', 'dog', 'moose')
#     True
#
#
# # Глава 7. Жаргон программистов
#
# В Python существует сборка мусора (garbage
# collection) — механизм автоматического управления памятью, который отслеживает выделение и освобождение памяти, чтобы программисту не приходилось заниматься этим самому.
#
# Литерал (literal) — текст в исходном коде программы, определяющий фиксированное типизованное значение.
#
# True, False и None считаются ключевыми словами Python, а не литералами, тогда как [] и {} называются
# индикаторами (displays) или атомами (atoms)
#
# Знаки мат операций, is, not, равенство и тд называются операторами
#
# Объект (object) представляет некоторый фрагмент данных: число, текст или более
# сложную структуру данных (такую как список или словарь). Все объекты могут
# сохраняться в переменных, передаваться в аргументах при вызове функций и возвращаться из вызовов функций.
# Каждый объект характеризуется значением, идентичностью и типом данных (value,
# identity и data type).
#
# Значение — данные, представляемые объектом
#
# идентичность — уникальное целое число, которое можно
# просмотреть вызовом функции id().
#
# Элемент - объект находящийся в объекте контейнере
#
# Последовательность (sequence) представляет собой объект любого контейнерного
# типа данных с упорядоченными значениями, к которым можно обращаться по
# целым индексам.
#
# Отображение (mapping) представляет собой объект любого контейнерного типа
# данных, использующий ключи вместо индексов.
#
# Dunder-методы, называемые также магическими, — это специальные методы
# в Python, которые используются для перезагрузки операторов. Их имена начинают-
# ся и заканчиваются двумя символами подчеркивания ( __ ).
#
# Модуль - импортируемый сборник программ Python
# Пакет - набор модулей
#
# Вызываемые объекты - объекты, реализующие оператор вызова ()
#
# Первоклассные объекты - объекты, которые можно присваивать, передавать в функции, возвращать.
#
# Выражениями (expressions) называются инструкции, состоящие из операторов и значений, результатом вычисления которых является одно значение.
#
# Блок, секция, тело - фрагмент кода, обрамленный отступами и обремененный одной целью
#
# Переменные (variables) — имена, ссылающиеся на объекты.
#
# Атрибут - любое имя, следующее за точкой
#
# Откомпилированная программа, состоящая из машинного кода,
# называется двоичным файлом
#
# Байт-код, также называемый портируемым (portable) кодом, или p-кодом, является аналогом машинного кода, но выполняется не напрямую процессором, а специальной программой — интерпретатором.
#
# Библиотека (library) — общий термин для подборки кодов, написанных третьей
# стороной.
#
# Фреймворком (framework) называется подборка кода, работающая по принципу
# инверсии управления; разработчик пишет функции, которые вызываются фреймворком по мере надобности
#
# SDK (Software Development Kit — комплект разработки ПО) — это программные
# библиотеки, документация и программные средства, упрощающие создание приложений для конкретной операционной системы или платформы.
#
# Ядро, или движок (engine), — крупная автономная система, которой могут управлять внешние программы разработчика.
#
# Интерфейс прикладного программирования, или API (Application Programming
# Interface), — интерфейс для работы с библиотекой, SDK, фреймворком или ядром,
# предназначенный для внешнего использования.
#
# # Глава 8. Часто встречающиеся ловушки Python
#
# ### Не добавляйте и не удаляйте элементы из списка
#
# в процессе перебора - вероятность столкнуться с бесконечным циклом очень высока.
#
# ### Также не стоит удалять элементы итерируемого списка в процессе цикла, так как смещение по индексам может привести к неверному результату.
#
# ### Python никогда не копирует объекты,
# он копирует только ссылки на них, так что при изменении первоначального объекта, изменяется последующие объекты, связанные со значением первоначального. Это можно решить поверхностным копированием объекта: copy.copy().
#
# ### Не используйте изменяемые значения для аргументов по умолчанию
#
# ### Не создавайте строки конкатенацией (string += string),
# так как это создает новую строку. При больших количествах итерации python каждый раз будет создавать новую строку и удалять старую, что совершено не эргономично. Гораздо лучше воспользоваться списком, добавлением туда нужных строк, а затем методом join. При 100 000 итераций процесс может ускориться в 10 раз.
#
# ### Не рассчитывайте, что sort() выполнит сортировку по алфавиту,
# так как он сортирует по кодовым пунктам, который разнится для одних и тех же букв в разном регистре, поэтому, чтобы получить нужный результат, стоит передать в sort() следующий аргумент:
#
# letters.sort(key=str.lower)
#
# Обратите внимание: реальные строки в списке не преобразуются к нижнему регистру; они только сортируются так, как если бы они к нему были преобразованы.
#
# ### Не рассчитывайте на идеальную точность чисел с плавающей точкой
#
# Проблему неточности можно решить с помощью библиотеки decimal
#
# ### Не объединяйте операторы != в цепочку
#
# ### Не забудьте запятую в кортежах из одного элемента
#
# В таких случаях кортеж итерирует переданный итерируемый объект, если он таким является, а с запятой кортеж будет воспринимать сам объект, а не его элементы
#
# # Глава 9. Экзотические странности Python.
#
# В целях оптимизации python создает объекты для целых чисел в диапазоне от -5 до 256, что позволяет экономить память и время, возвращая, в случае создания такое объекта пользователем, уже существующий объект, вместо создания нового.
#
# ### Интернирование строк
#
# Если двум переменным присвоено одинаковое значение, Python присваивает второй переменной ссылку на первую, в целях оптимизации.
#
# >>> bacon = 'c'
#
# >>> bacon += 'at'
#
# >>> spam is bacon
#
# False - в таком случае python не применяет интернирование.
#
# ### Фиктивные операторы инкремента и декремента в языке Python
#
# >>> spam = 42
#
# >>> spam = --spam
#
# >>> spam
# 42
#
# ### Функция all()
#
# позволяет проверить все элементы итерируемого объекта на ложность или правдивость, и если хотя бы один из них ложен, функция вернет False, иначе True. Правильнее считать, что all([]) проверяет утверждение «ни один из элементов списка не является ложным»
#
# ### Логические значения как целые числа
#
# >>> int(False)
#
# 0
#
# >>> int(True)
#
# 1
#
# >>> True == 1
#
# True
#
# >>> False == 0
#
# True
#
#
# >>> isinstance(True, bool)
#
# True
#
# >>> isinstance(True, int)
#
# True
#
# # Глава 10. Написание эффективных функций.
#
# ### Плюсы и минусы размера функций
#
# **Плюсы коротких функций**
#
# - Код функции проще понять.
#
# - Функции, скорее всего, требуется меньше параметров.
#
# - Снижается вероятность побочных эффектов
#
# - Упрощается тестирование и отладка функции
#
# - Вероятно, функция будет выдавать меньше разных видов исключений.
#
# **Однако у коротких функций имеются свои недостатки.**
#
# - Написание коротких функций часто означает увеличение их числа в программе.
#
# - Чем больше функций, тем сложнее становится программа.
#
# - Увеличение количества функций также означает, что вам придется придумывать больше содержательных и точных имен, а это не так просто.
#
# - Вам придется писать больше документации.
#
# - Чем больше функций, тем сложнее связи между ними.
#
# ### Параметры и аргументы функций
#
# Из не должно быть больше 5 - 6, иначе лучше разбить такую функцию на несколько малых.
#
# **Решения**
#
# Аргументы по умолчанию.
#
# Вы можете использовать синтаксисы * и ** для раздельной передачи групп аргументов функциям. Синтаксис * позволяет передать элементы итерируемого объекта (такого как список или кортеж). Синтаксис ** позволяет передавать пары
# «ключ — значение» из объекта отображения (например, словаря) как отдельные аргументы.
#
# Использование *args при создании вариадических функций - синтаксис * также означает неопределенное количество аргументов, например print(), куда можно передать сколько угодно строк.
#
# Внутри функции *args — обычный кортеж Python, содержащий все позиционные
# аргументы.
#
# Также используется синтаксис **kwargs
#
# kwargs — это просто имя переменной, хотя по соглашению чаще всего используется именно kwargs (сокращение от keyword arguments).
#
# Звёздочки ** перед именем говорят Python, что нужно собрать все именованные аргументы (ключи и значения) в словарь
#
# ### Использование * и ** для создания функций-оберток
#
# Синтаксисы * и ** в командах def часто используются для создания функций-оберток, которые передают аргументы другой функции и возвращают возвращаемое значение этой функции.
#
# #### Функциональное программирование
#
# Функциональное программирование — парадигма программирования, уделяющая
# особое внимание написанию функций, которые выполняют вычисления без изменения глобальных переменных или какого-либо внешнего состояния (файлов на жестком диске, подключений к интернету или баз данных).
#
# **Детерминированняая функция** - это функция, которая при передаче одного и того же набора элементов возвращает одинаковый результат.
#
# round(5.6)
#
# **Недетерминированная функция** - это функция, которая при передаче одного и того же набора элементов возвращает разный результат.
#
# random.randint(1, 10)
#
# Одно из преимуществ детерминированных функций — возможность кэширования
# их значений. Они запоминают результат выполнения функции с определенным набором параметров.
#
# **Функции высшего порядка** это функции которые могут получать другие функции
# в аргументах или использовать функции как возвращаемые значения.
#
# >>> def callItTwice(func, *args, **kwargs):
#
# ... func(*args, **kwargs)
#
# ... func(*args, **kwargs)
#
# ...
# >>> callItTwice(print, 'Hello, world!')
#
# Hello, world!
#
# Hello, world!
#
# **Лямбда функции** - упрощенные функции, 'неглобальная' альтернатива обычным
#
# ### Возвращаемые значения всегда должны иметь один тип данных
#
# # Глава 11. Комментарии, doc-строки и аннотации типов
#
# ### Комментарии
# для однострочного комментария подойдет синтаксис #, а длинный комментарий лучше записать через """"""
#
# Для комментариев лучше использовать предложения в отдельно выделенных строках, а не в конце строк после кода.
# Встроенные комментарии, которые служат для объяснения смысла какой-либо строчки кода, пишутся как раза таки в конце строк после самого кода.
#
# **Магические комментарии и кодировка исходных файлов**
#
# # #!/usr/bin/env python3 ❶
# #-*- coding: utf-8 -*-
#
# Строка 1 сообщает вашей операционной системе, какой интерпретатор следует использовать для выполнения инструкций в файле.
# Второй магический комментарий в строке 2 определяет кодировку.
#
# ### Doc-строки
#
# Doc-строки представляют собой многострочные комментарии, расположенные либо
# в начале файла .py с исходным кодом модуля, либо непосредственно после команды class или def. Они содержат документацию об определяемом модуле, классе, функции или методе.
#
# ### Аннотации типов
#
# В Python используется как необязательная деталь, проверяется mypy
#
# # Глава 12. Git и организация программных проектов
#
# **Git** - обширная система управления версиями, имеющая удаленный GitHub, где можно сохранять свои файлы и их версии.
#
# ### Коммиты и репозитории
#
# Git позволяет сохранить состояние файлов проекта при внесении в них изменений.
# Такие сохранения называются снимками (snapshots) или коммитами (commits).
#
# Система контроля версий управляет исходным кодом проекта, который хранится
# в специальной папке — репозитории (repo). Как правило, для каждого проекта,
# над которым вы работаете, следует создать отдельный репозиторий Git.
#
#
# ### Работа с git
#
# Возможные состояния файла:

# ![image.png](attachment:image.png)

# На любом этапе после создания репозитория выполните команду git status для
# просмотра текущего статуса репозитория и состояния его файлов.
#
# # Глава 13. Измерение быстродействия и анализ сложности алгоритмов
#
# ### Модуль timeit
#
# Модуль timeit стандартной библиотеки Python способен измерить скорость
# выполнения небольшого фрагмента кода. Для этого его запускают тысячи или
# миллионы раз, после чего вычисляют среднее время выполнения. Модуль timeit
# также временно отключает автоматический сборщик мусора для получения более
# стабильных данных времени выполнения. Если вы хотите вычислить время выполнения нескольких строк, передайте многострочный текст или разделите строки
# кода символами ;:
#
# >>> import timeit
#
# >>> timeit.timeit('a, b = 42, 101; a = a ^ b; b = a ^ b; a = a ^ b')
#
# 0.1307766629999998
#
# По умолчанию код строки, переданной timeit.timeit(), не может обращаться
# к переменным и функциям в остальном коде программы - для решения этой проблемы в функцию нужно передать еще один аргумент -  globals=globals()
#
#
# ### Профилировщик cProfile
#
# Хотя модуль timeit полезен для хронометража небольших фрагментов кода, модуль
# cProfile более эффективен для анализа целых функций или программ.

# Результат выполнения этой программы выглядит примерно так:
#
# 4 function calls in 0.064 seconds
#
# Ordered by: standard name
#
#   ncalls tottime percall cumtime percall filename:lineno(function)
#
#      1     0.000  0.000   0.064   0.064 <string>:1(<module>)
#
#      1     0.064  0.064   0.064   0.064 test1.py:2(addUpNumbers)
#
#      1     0.000  0.000   0.064   0.064 {built-in method builtins.exec}
#
#      1     0.000  0.000   0.000   0.000 {method 'disable' of '_lsprof.
#                                          Profiler' objects}
#
#
# ncalls — количество вызовов функции;
#
# tottime — общее время, требуемое для выполнения функции, не считая
# времени в подфункциях;
#
# percall — общее время, разделенное на количество вызовов;
#
# cumtime — накопленное время для выполнения функции и ее подфункций;
#
# percall — общее время, деленное на количество вызовов;
#
# filename:lineno(function) — файл, в котором определяется функция, и но-
# мер строки.
#
#
# ### Анализ алгоритмов с использованием нотации «O-большое»
#
# Нотация «О-большое» — метод анализа алгоритмов, описывающий масштабирование времени выполнения кода. Код классифицируется по нескольким порядкам сложности, каждый из которых в общем виде показывает, насколько увеличится время выполнения кода при возрастании объема выполняемой работы.
#
# #### Порядки нотации «О-большое»
#
# 1. O(1), постоянное время (самый низкий порядок).
#
# 2. O(log n), логарифмическое время.
#
# 3. O(n), линейное время.
#
# 4. O(n log n), время N-Log-N.
#
# 5. O(n**2), полиномиальное время.
#
# 6. O(2**n), экспоненциальное время.
#
# 7. O(n!), факториальное время (наивысший порядок).
#
# O(1) и O(log n) — быстрые алгоритмы.
#
# O(n) и O(n log n) — неплохие алгоритмы.
#
# O(n2), O(2n) и O(n!) — медленные алгоритмы.
#
# ### Определение порядка сложности нотации «О-большое» вашего кода
#
# Чтобы определить порядок сложности нотации «О-большое» для фрагмента кода,
# необходимо решить четыре задачи: определить n, подсчитать шаги в коде, исключить
# нижние порядки и исключить коэффициенты.
#
# для n отлично подходят длина итерируемого списка, массива, нужное количество элементов и тд.
#
# Строка, содержащая выполнение какого либо действия - применение функции, присвоение переменной какого-либо значения, создание переменной, математическая операция, будет равна одному шагу, цикл - n * количество таких шагов в цикле
#
# Исключить нижние порядки - оставить только большее слагаемое из получившегося выражения, например:
#
# Выражение 2n + 3 состоит из двух порядков, линейного (2n) и постоянного (3).
# Если оставить только больший из этих порядков, остается 2n
#
# Затем из порядка исключаются коэффициенты. В 2n коэффициентом является 2.
# После исключения остается n. В результате мы получаем итоговую метрику нотации «О-большое» для функции readingList(): O(n), то есть линейная сложность.
#
# Низкие порядки исключаются из подсчета шагов, потому что они становятся менее
# значимыми с увеличением размера n. Если список books из приведенной функции
# readingList() увеличивается с 10 до 10 000 000 000, количество
# шагов увеличится с 23 до 20 000 000 003. При достаточно больших n эти три дополнительных шага ни на что не влияют.
#
# В списке показаны порядки некоторых распространенных операций Python для
# типов последовательностей — таких как строки, кортежи и списки.
#
# s[i] reading и s[i] = value assignment — операции O(1).
#
# s.append(value) — операция O(1).
#
# s.insert(i, value) — операция O(n). Вставка значения в последовательность
#
# (особенно в начало) требует сдвига всех элементов с индексами выше i на одну позицию вверх в последовательности.
#
# s.remove(value) — операция O(n). Удаление значений из последовательности
# (особенно в начале) требует сдвига всех элементов с индексами выше i на
# одну позицию вниз в последовательности.
# s.reverse() — операция O(n), потому что необходимо переставить все эле-
# менты последовательности.
#
# s.sort() — операция O(n log n), потому что алгоритм сортировки Python
# имеет сложность O(n log n).
#
# value in s — операция O(n), потому что необходимо проверить каждый
# элемент.
#
# for value in s: — операция O(n).
#
# len(s) — операция O(1), потому что Python хранит количество элементов
# в последовательности, чтобы их не приходилось заново пересчитывать при
# каждом вызове len().
#
# ### Моментальный анализ сложности
#
# - Если код не обращается ни к каким данным, это O(1).
#
# - Если код последовательно перебирает данные, это O(1).
#
# - Если код содержит два вложенных цикла, каждый из которых перебирает
# данные, это O(n2).
#
# - Вызовы функций включаются в подсчеты не как один шаг, а как общее количество шагов кода внутри функции.
#
# - Если код содержит операцию «разделяй и властвуй», которая многократно
# делит данные надвое, это O(log n).
#
# - Если код содержит операцию «разделяй и властвуй», которая выполняется
# по одному разу для каждого элемента данных, это O(n log n).
#
# - Если код перебирает все возможные комбинации значений в данных с размером n, это O(2n) или другой экспоненциальный порядок.
#
# - Если код перебирает все возможные перестановки (то есть варианты упорядочения) значений данных, это O(n!).
#
# - Если код включает сортировку данных, это как минимум O(n log n).
#
# Нотация «О-большое» полезна прежде всего при большом объеме обрабатываемых
# данных. В реальных ситуациях объем данных обычно невелик.

# ![image.png](attachment:image.png)

# # Глава 15. Объектно-ориентированное программирование и классы
#
# Объектно-ориентированное программирование, или
# ООП, — механизм языка программирования, позволяю-
# щий группировать переменные и функции в новые типы
# данных, называемые классами.
#
# ### Методы, __init__() и self
#
# Методы представляют собой функции, связанные с объектами некоторого класса.
#
# __init__() = вызов конструктора класса, с помощью него создаются его атрибуты
#
# Атрибутами называются переменные, связанные с объектом.
#
# # Глава 16. ООП и наследование.
#
# Наследование (inheritance) представляет собой метод повторного использования
# кода, который применяется к классам. Это механизм организации классов в си-
# стеме отношений «родитель — потомок», в которой дочерний класс наследует
# копию методов своего родительского класса, что избавляет вас от необходимости
# дублировать код метода в нескольких классах.

# ![image.png](attachment:image.png)

# Отношения являются односторонними: объект ParentClass не является объектом ChildClass. Если объект ParentClass
# попытается вызвать метод someNewMethod(), существующий только для объектов
# ChildClass (и субклассов ChildClass), Python выдает ошибку AttributeError.
#
# Дочерние классы также иногда называются производными классами, или субклассами, а родительские классы — базовыми классами, или суперклассами.
#
# ## Переопределение методов
#
# Дочерние классы наследуют все методы своих родительских классов. Но дочерний
# класс может переопределить унаследованный метод, предоставляя собственный
# метод с собственным кодом. Имя переопределяющего метода дочернего класса
# совпадает с именем метода родительского класса.
#
# ## Функция super()
#
# Функция super() используется для вызова метода родительского класса в теле дочернего.
#
# Главный недостаток наследования связан с тем, что любые будущие изменения
# в родительском классе обязательно наследуются всеми его дочерними классами.
#
# ## Функции isinstance() и issubclass()
#
# Функция isinstance() вернет True, если объект относится к заданному классу или одному из его субклассов.
#
# >>> isinstance(42, (int, str, bool)) # True, если 42 имеет тип int, str или bool.
#
# True
#
# Встроенная функция issubclass() — она используется реже — может сообщить,
# является ли объект класса, переданный в первом аргументе, субклассом (или относится к тому же классу), что и объект класса, переданный во втором аргументе:
#
# >>> issubclass(ChildClass, ParentClass) # ChildClass субклассирует ParentClass.
#
# True
#
# >>> issubclass(ChildClass, str) # ChildClass не субклассирует str.
#
# False
#
# >>> issubclass(ChildClass, ChildClass) # ChildClass имеет тип ChildClass.
#
# True
#
# **Атрибут класса** представляет собой переменную, которая принадлежит классу, а не объекту.
#
# **Метод класса** связывается с классом, а не с его отдельными объектами.
#
# ## Статические методы
#
# Статический метод не имеет параметра self или cls. Он не обращается к атрибутам объекта класса или самого класса
#
# ## Когда использовать объектно-ориентированные статические средства и средства уровня классов
#
#  Они могут пригодиться, если вы создаете
# собственный фреймворк с нетривиальным семейством классов, которые должны
# субклассироваться программистами, использующими фреймворк. Скорее всего,
# при написании обычных приложений Python они вам не понадобятся.
#
# - Если ваш класс состоит из методов, в которых совсем не используются параметры self или cls, удалите класс и примените функции вместо методов.
#
# - Если вы создали родителя, который имеет только один дочерний класс, но объекты родительского класса нигде не используются, их можно объединить в один класс.
#
# - Если вы создаете более трех или четырех уровней субклассирования, вероятно, вы злоупотребляете наследованием. Переработайте субклассы и уберите лишние.
#
#
#
# ## Термины ООП
#
# Инкапсуляция - объединение взаимосвязанных данных и кода в одно целое  / также это сокрытие сложной реализации в угоду читаемости.
#
# Полиморфизм позволяет рассматривать объекты одного типа как объекты другого типа.
#
#
# # Глава 17. ООП в Python: свойства и dunder-методы.
#

# ![image.png](attachment:image.png)

# ## Dunder-методы Python
#
# Они часто используются для перегрузки операторов — то есть добавления нестандартного поведения, позволяющего использовать объекты ваших классов с операторами Python, такими как + или >=. Другие dunder-методы позволяют объектам
# классов работать со встроенными функциями Python, такими как len() или repr().
#
# ### Числовые dunder-методы
#
# Числовые dunder-методы, также называемые математическими dunder-методами, перегружают математические операторы Python: +, - и т. д., то есть, объект созданного вами класса может быть и неспособным взаимодействовать с математическими операциями, но создав метод __add__ (обычно +) или __mul__ (*) вы можете сделать так, чтобы он с ними взаимодействовал так, как вы этого хотите.
#
# **Важно**: в dunder методе не стоит изменять self-объект, так как dunder методы должны возвращать новый объект с примененными к нему изменениями.

# ![image.png](attachment:image.png)

# ### Отраженные числовые dunder-методы

# Python вызывает числовые dunder-методы, когда объект находится в левой части математического оператора. Но если объект располагается в правой части математического оператора, то вызываются отраженные числовые dunder-методы.
#
# Отраженные и обычные числовые dunder методы имеют одинаковый код если их мат операции имеют свойство коммутативности. (+ / *)

# ![image.png](attachment:image.png)

# ### Dunder-методы присваивания на месте (in-place)
#
# Вместо того, чтобы создавать новый объект, они изменяют self.
#
#
# ### Dunder-методы сравнения
#
# Они используются, чтобы дать объектам класса сравниваться математически - >, <, ==.

#
